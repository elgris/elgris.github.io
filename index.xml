<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>creating software rocks!</title>
    <link>http://elgris.github.io/</link>
    <description>Recent content on creating software rocks!</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 24 Mar 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://elgris.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Happy Birthday Docker!</title>
      <link>http://elgris.github.io/blog/5_docker_birthday/</link>
      <pubDate>Thu, 24 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://elgris.github.io/blog/5_docker_birthday/</guid>
      <description>

&lt;p&gt;Look at him! 3 years old baby which is growing and growing and growing!&lt;/p&gt;

&lt;p&gt;Celebrating birthdays of such tools is a good idea in general. Why? Because attendees of such events are usually students or people not familiar (much) with technology. I have participated at Docker Birthday #3 at RMIT (Ho Chi Minh City, Vietnam) as mentor and what I&amp;rsquo;d say: local students need MOAR Docker.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://elgris.github.io/img/5_docker_birthday/docker_birthday.jpg&#34; alt=&#34; Docker Birthday! !&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Students are smart and eager to learn. But, unfortunately, nobody teaches them new IT stuff. The reason is clear: IT changes every day and universities must use some kind of plan or programme. With fast pacing technology, the plan must also change every day, it&amp;rsquo;s impossible to keep it up.&lt;/p&gt;

&lt;p&gt;And that reminds me of my own days in university and makes me a little bit sad. We were given fundamental stuff (which is good), but had no idea how and where to apply it because &lt;strong&gt;we were not given any practical lesson or real world example&lt;/strong&gt;. I believe, it&amp;rsquo;s kinda common problem with conservative and beaurocratic Universities. Thus, I beg you Big Guys - Docker, Google, Amazon, Microsoft, whoever else - please keep running events for students. Celebrate birthdays of your technologies. Introduce new tools. Run meetups. But make it offline, so students come, play, experiment, ask mentors and get answers.&lt;/p&gt;

&lt;p&gt;Why offline? Well, despite online training sessions are a way easier to set up and run, offline meetups provide real contact. I mean, real eye-to-eye contact between students and mentors. Mentors share not only knowledge, they also share energy and inspiration (good mentors must do that), the things which difficult to transmit over network, you have to &lt;strong&gt;feel&lt;/strong&gt; them.&lt;/p&gt;

&lt;p&gt;Of course, many people, especially already trained professionals, feel fine with online sessions. They join online meetups with some kind of expectations and (possibly) with a set of questions they want to ask.&lt;/p&gt;

&lt;p&gt;In contrast, students have no idea what&amp;rsquo;s this technology is about, they barely touched it and it&amp;rsquo;s OK. In such case event organizer needs not only to present the new cool technical stuff, but transmit his/her passion and inspiration to attendees. From my experience, it&amp;rsquo;s difficult to do online. So we need offline events that spread knowledge, socialize and make people &lt;strong&gt;want&lt;/strong&gt; to try new freshly presented product. You know, students can be very creative, you never know what they invent with your tool if you make them inspired :) Maybe they will create one more &amp;ldquo;Minecraft + Docker&amp;rdquo; crazy thing? Or some service that occasionally earn billions?&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s what I call &amp;ldquo;investing into people&amp;rdquo;. And I believe that such kind of investment brings huge profit in long term.&lt;/p&gt;

&lt;h2 id=&#34;p-s:386596c23df0f1529803640c9c2e5e7a&#34;&gt;P.S.&lt;/h2&gt;

&lt;p&gt;Thanks to &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; for Birthday Event!&lt;/p&gt;

&lt;p&gt;Special thanks goes to &lt;a href=&#34;http://seesawlabs.com/&#34;&gt;SeeSaw Labs&lt;/a&gt; for sponsorship! The cupcakes were delicious! =)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FOSSAsia conference, Singapore</title>
      <link>http://elgris.github.io/blog/4_fossasia/</link>
      <pubDate>Tue, 22 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://elgris.github.io/blog/4_fossasia/</guid>
      <description>&lt;p&gt;Finally got somewhere big and IT. Welcome to FOSS Asia IT conference that took place at Singapore at 18-20th of March.&lt;/p&gt;

&lt;p&gt;What did I see there? Well, a lot of people willing to learn. Some of the talks were really mindblowing, but majority of them were average. It doesn&amp;rsquo;t mean they were bad, they were not hardcore, meaning no crazy hacks or benchmarks or extremely low-level code surgery. But they were educating and very useful for students and those who wants to take a look at some other technology, tool or idea. Sometimes there were kinda weird but funny topics :D.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://elgris.github.io/img/4_fossasia/fossasia.jpg&#34; alt=&#34; IT talks. About sex. !&#34; /&gt;&lt;/p&gt;

&lt;p&gt;My own talk was about &amp;ldquo;Yet Another Testing Tool&amp;rdquo; &amp;copy; that allows you to generate documentation for RESTful API. Yes, it&amp;rsquo;s &lt;a href=&#34;https://github.com/seesawlabs/apitest&#34;&gt;apitest&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;WARNING! Lots of fun, gifs, kittens and a couple lines of code ahead! :D. If you&amp;rsquo;re interested in demo example, please &lt;a href=&#34;https://github.com/seesawlabs/apitest/tree/master/example&#34;&gt;check it here&lt;/a&gt;.&lt;/p&gt;

&lt;iframe src=&#34;https://docs.google.com/presentation/d/14JdRvqYO6famsyiHhmyU6rc0RudQZ7FJB39wN9CL-pM/embed?start=false&amp;loop=false&amp;delayms=3000&#34; frameborder=&#34;0&#34; width=&#34;683&#34; height=&#34;541&#34; allowfullscreen=&#34;true&#34; mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34; style=&#34;display:block;margin: 0 auto;&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Photos are here: &lt;a href=&#34;https://www.flickr.com/photos/comprock/25757208022/in/pool-fossasia-2016/&#34;&gt;https://www.flickr.com/photos/comprock/25757208022/in/pool-fossasia-2016/&lt;/a&gt;
Thanks &lt;a href=&#34;https://axelerant.com/team-member/michael-cannon/&#34;&gt;Michael Cannon&lt;/a&gt; for great photography work!!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Appium VS Calabash</title>
      <link>http://elgris.github.io/blog/2_appium_vs_calabash/</link>
      <pubDate>Sat, 12 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://elgris.github.io/blog/2_appium_vs_calabash/</guid>
      <description>

&lt;p&gt;OK, what do we have here? A mobile application written with Cordova for 2 platforms: iOS and Android. I&amp;rsquo;m lazy, I don&amp;rsquo;t want to check that all critical functionality works as expected after each release. In 2 platforms. And I don&amp;rsquo;t want anyone to do that, because manual work is stupid in IT. So I need a proper tool to test both applications automatically, so I have enought free time to explore the world around me :)&lt;/p&gt;

&lt;h1 id=&#34;tl-dr:114248fa596f687622d06d2e1a31c068&#34;&gt;TL;DR&lt;/h1&gt;

&lt;p&gt;Decided to go with &lt;a href=&#34;http://calaba.sh&#34;&gt;Calabash&lt;/a&gt; at the end.&lt;/p&gt;

&lt;h1 id=&#34;constraints:114248fa596f687622d06d2e1a31c068&#34;&gt;Constraints&lt;/h1&gt;

&lt;p&gt;All right, let&amp;rsquo;s define following constraints:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I want to write tests once (or at least write as less code as possible :) ) and run them against both Android and iOS builds.&lt;/li&gt;
&lt;li&gt;I need to test &lt;strong&gt;hybrid&lt;/strong&gt; application created with &lt;a href=&#34;https://cordova.apache.org/&#34;&gt;Cordova&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;I&amp;rsquo;d like to write tests in Javascript, because in &lt;a href=&#34;http://www.seesawlabs.com/&#34;&gt;SeeSaw Labs&lt;/a&gt; we use plenty of it, so many people can support the tests.&lt;/li&gt;
&lt;li&gt;Tests must be readable. Ideally, written in Gherkin, but some framework that provides &lt;a href=&#34;http://frisbyjs.com/&#34;&gt;frisby&lt;/a&gt;-like syntax is OK also.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is not so many frameworks that satisfy constraint 1. So I ended up with two of them: &lt;a href=&#34;http://appium.io&#34;&gt;Appium&lt;/a&gt; and &lt;a href=&#34;http://calaba.sh&#34;&gt;Calabash&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;what-s-good-about-appium:114248fa596f687622d06d2e1a31c068&#34;&gt;What&amp;rsquo;s good about Appium?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;No need to link any additional code to your application. Just build it, run it (emulator is fine), Appium will do the rest.&lt;/li&gt;
&lt;li&gt;Easy debugging. Appium uses WebDriver API which can be used with any HTTP client (&lt;code&gt;curl&lt;/code&gt; to the rescue).&lt;/li&gt;
&lt;li&gt;Fancy UI that allows you to investigate layout of pages, prepare queries to the elements and even record test scenarios like Selenium IDE.&lt;/li&gt;
&lt;li&gt;Integrates with CucumberJS very easy. Basically, you just write your tests with CucumberJS and communicate to Appium with webdriver client.&lt;/li&gt;
&lt;li&gt;If you know how to write tests for Selenium WebDriver - you already know how to use Appium.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;what-s-wrong-with-appium:114248fa596f687622d06d2e1a31c068&#34;&gt;What&amp;rsquo;s wrong with Appium?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Doesn&amp;rsquo;t work well with hybrid applications on Android. In my case it was impossible to determine an element on page. The coordinates of an elements were changing each time I scrolled the page.
&lt;img src=&#34;http://elgris.github.io/img/2_appium_vs_calabash/android.png&#34; alt=&#34; where is the EditText element you say? o_O !&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Doesn&amp;rsquo;t work well with Cordova app on iOS with iOS SDK that comes with Xcode 7.2. The problem is: somehow the elements (buttons, labels, inputs) are &amp;ldquo;disabled&amp;rdquo;, so Appium just does not see them and cannot interact with them. Look at the screenshot. Appium Inspector was told not to show &amp;ldquo;disabled&amp;rdquo; elements. Dude, where&amp;rsquo;s my button then? :)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info: [debug] Responding to client with error: {&amp;quot;status&amp;quot;:7,&amp;quot;value&amp;quot;:{&amp;quot;message&amp;quot;:&amp;quot;An element could not be located on the page using the given search parameters.&amp;quot;,&amp;quot;origValue&amp;quot;:&amp;quot;&amp;quot;},&amp;quot;sessionId&amp;quot;:&amp;quot;eccc5b20-a5dd-4f41-9ce8-c16964e3f64c&amp;quot;}
info: &amp;lt;-- POST /wd/hub/session/eccc5b20-a5dd-4f41-9ce8-c16964e3f64c/element 500 754.829 ms - 179
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is an issue about that: &lt;a href=&#34;https://github.com/appium/appium/issues/4131&#34;&gt;https://github.com/appium/appium/issues/4131&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Documentation is scarce, I spent lots of time to deliver first test.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;what-s-good-about-calabash:114248fa596f687622d06d2e1a31c068&#34;&gt;What&amp;rsquo;s good about Calabash?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;It works. It just works with hybrid app on both platforms. Of course, there is some diference between APIs for Android and iOS, but everything is well documented. There is even examples that cover more 80% of your needs: &lt;a href=&#34;https://github.com/calabash/x-platform-example&#34;&gt;https://github.com/calabash/x-platform-example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;There is a good tutorial about linking Calabash library to iOS build: &lt;a href=&#34;https://github.com/calabash/calabash-ios/wiki/Tutorial%3A--Creating-a-cal-Target&#34;&gt;https://github.com/calabash/calabash-ios/wiki/Tutorial%3A--Creating-a-cal-Target&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Cucumber out of the box.&lt;/li&gt;
&lt;li&gt;Command-line tool that allows debugging: &lt;code&gt;calabash-android console&lt;/code&gt; and &lt;code&gt;calabash-ios console&lt;/code&gt;. That&amp;rsquo;s how I inspected application pages and debugged interaction with elements using selectors.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;what-s-wrong-with-calabash-then:114248fa596f687622d06d2e1a31c068&#34;&gt;What&amp;rsquo;s wrong with Calabash then?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Ruby only :(&lt;/li&gt;
&lt;li&gt;Need to prepare special target to build iOS application&lt;/li&gt;
&lt;li&gt;No fancy UI which could help a lot with finding proper selector of the element&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;what-s-at-the-end:114248fa596f687622d06d2e1a31c068&#34;&gt;What&amp;rsquo;s at the end?&lt;/h1&gt;

&lt;p&gt;I decided to go with &lt;a href=&#34;http://calaba.sh&#34;&gt;Calabash&lt;/a&gt;. Despite it does not have Javascript bindings (yet), writing Ruby code was easy and fun. Actually, by the end of first day I have successfully set up all required infrastructure, ran first test on both platforms and prepared a tutorial for the rest of the team.&lt;/p&gt;

&lt;p&gt;I would recommend Appium to those who makes native applications. With hybrid apps (at least Cordova-based) I ran into bunch of problems. Perhaps those problems could be solved, but &lt;strong&gt;learning Ruby was much faster&lt;/strong&gt; than solving those artificial problems.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Coworking space in Nha Trang, Vietnam</title>
      <link>http://elgris.github.io/blog/3_coworking_nha_trang/</link>
      <pubDate>Sat, 12 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://elgris.github.io/blog/3_coworking_nha_trang/</guid>
      <description>&lt;p&gt;Found a nice coworking space in Nha Trang, Vietnam: &lt;a href=&#34;http://livincollective.tumblr.com/&#34;&gt;LivinCollective&lt;/a&gt;. Check &lt;a href=&#34;https://www.google.com/maps/place/LIVINcollective/@12.24055,109.191345,15z/data=!4m2!3m1!1s0x0:0x9e9b8620219644fb?sa=X&amp;amp;ved=0ahUKEwjP8PHApbvLAhVTGo4KHf4_CxcQ_BIIcTAK&#34;&gt;the map&lt;/a&gt;. The place is comfortable, the hosts are really friendly. Working there is free, but it would be great if you buy something (juice or coffee or something to eat) to help run the place. WiFi there was the fastest I had in Nha Trang :)&lt;/p&gt;

&lt;p&gt;Some pictures of the place:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://elgris.github.io/img/3_coworking_nha_trang/IMG_0131.jpg&#34; alt=&#34; coworking space !&#34; /&gt;
&lt;img src=&#34;http://elgris.github.io/img/3_coworking_nha_trang/IMG_0132.jpg&#34; alt=&#34; again, coworking space !&#34; /&gt;
&lt;img src=&#34;http://elgris.github.io/img/3_coworking_nha_trang/IMG_0134.jpg&#34; alt=&#34; view from the second floor !&#34; /&gt;
&lt;img src=&#34;http://elgris.github.io/img/3_coworking_nha_trang/IMG_0135.jpg&#34; alt=&#34; and don&#39;t forget to buy something to drink :) !&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apitest - test and document that</title>
      <link>http://elgris.github.io/blog/1_apitest/</link>
      <pubDate>Sun, 21 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://elgris.github.io/blog/1_apitest/</guid>
      <description>

&lt;p&gt;Everybody knows that using an API with no documentation is like walking on a minefield with no map.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://elgris.github.io/img/apitest/1.jpg&#34; alt=&#34;danger!&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;http://seesawlabs.com&#34;&gt;SeeSaw Labs&lt;/a&gt; we build APIs and we&amp;rsquo;re doing our best to provide our customers with such a map :)&lt;/p&gt;

&lt;p&gt;But how to write a documentation? Here are 3 general approaches.&lt;/p&gt;

&lt;h2 id=&#34;1-do-it-manually:953fe4fc11a9836b4a4465fc46f3be77&#34;&gt;1. Do it manually&lt;/h2&gt;

&lt;p&gt;Sounds obvious, right? You write the code, you write documentation for it separately. Sounds easy. Now add several dozens of API endpoints and a dozen of developers into this cocktail. Shake it. Boom - you got Molotov Cocktail! :)&lt;/p&gt;

&lt;p&gt;Manually maintained documentation &lt;em&gt;for code&lt;/em&gt; becomes inaccurate very soon. Sometimes developers just forget updating it. When you keep your documentation control of some VCS you can get merge conflict which is painful for large APIs. It gets even more painful when you have to maintain documentation for systems like Swagger or Postman. C&amp;rsquo;mon, humans must not maintain documentation for machine, it&amp;rsquo;s called slavery :)&lt;/p&gt;

&lt;p&gt;Also it adds extra step to your workflow (which can and should be avoid): &amp;ldquo;Doc review&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Please note that comments to the code also count as &amp;ldquo;manual documentation&amp;rdquo;. You have to write them separately, you have to update them and at some point comments begin to smell&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;You got the map, but are you sure it&amp;rsquo;s accurate?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://elgris.github.io/img/apitest/2.jpg&#34; alt=&#34;you have a map, but is it accurate? !&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-generate-from-code:953fe4fc11a9836b4a4465fc46f3be77&#34;&gt;2. Generate from code&lt;/h2&gt;

&lt;p&gt;The most useful approach which adds constraints so you just &lt;strong&gt;cannot&lt;/strong&gt; write undocumented code. Documentation generates not from comments, not from annotations, but directly from actual live code. Frameworks like &lt;a href=&#34;http://goa.design/&#34;&gt;goa&lt;/a&gt; or &lt;a href=&#34;https://github.com/emicklei/go-restful&#34;&gt;go-restful&lt;/a&gt; help you with this.&lt;/p&gt;

&lt;p&gt;Such frameworks are extremely useful when you start to implement your API with them. Unfortunately, if you already have &amp;ldquo;legacy&amp;rdquo; code to maintain - usually it&amp;rsquo;s huge pain to refactor it to meet requirements of a framework.&lt;/p&gt;

&lt;p&gt;Often they limit your creativity by offering predefined set of tools for, e.g., routing, middleware chains, logging and so on. Frankly speaking, many people don&amp;rsquo;t need fine tuning on transport level since they have a lot of &amp;ldquo;freedom&amp;rdquo; (and problems) on business logic level, so predefined components just remove a part of their work and make their life a little bit easier.&lt;/p&gt;

&lt;p&gt;Also, such way gives you description, but does not provide examples. You have to forge them by yourself, keep somewhere and maintain well, so people can try your API in action with no frustration. Most probably you will do it manually like described in #1. Wellcome to Hell again :)&lt;/p&gt;

&lt;p&gt;Another drawback is that documentation does not ensure that your API will act exactly as documented. You may have absolutely correct example, absolutely descriptive documentation, but after some minor change in business logic your example may become invalid. You just have no tests for your examples&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Now you got some protection, but you&amp;rsquo;re still in danger&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://elgris.github.io/img/apitest/3.jpg&#34; alt=&#34;now you got some protection&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-generate-from-tests:953fe4fc11a9836b4a4465fc46f3be77&#34;&gt;3. Generate from tests&lt;/h2&gt;

&lt;p&gt;Now we came to 3rd way of getting documentation as well as guaranteed working examples. Automatically. Tests! Holy Grail of software development! :)
This approach works best when you have legacy code. Indeed, no need to refactor the whole codebase at once, you can cover your API with tests, put your test code separately and use it for docs generation. This is the way offered you by &lt;a href=&#34;https://github.com/seesawlabs/apitest&#34;&gt;apitest framework&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You get other benefits like:
- test coverage which helps a lot with refactoring.
- tests are great source of examples for documentation! At the end you get docs that are &amp;ldquo;alive&amp;rdquo;, clickable and can be tried by anyone who interested. Examples are generated automatically, thus you get rid of all manual documentation maintenance.&lt;/p&gt;

&lt;p&gt;However, this approach is not ideal. First of all, application tests which are used for docs generation (at least with &lt;a href=&#34;https://github.com/seesawlabs/apitest&#34;&gt;apitest&lt;/a&gt;) are not unit tests. They require running API instance along with all dependencies (like database or external services) or lots of mocks. Such tests can take too much time to run. Also there is not 100% guarantee that your tests produce complete documentation. Some parts may be missing, it depends on how you write code, how you write tests and how you control test coverage metric.&lt;/p&gt;

&lt;h2 id=&#34;4-combine-generation-from-code-and-from-tests:953fe4fc11a9836b4a4465fc46f3be77&#34;&gt;4. Combine generation from code and from tests&lt;/h2&gt;

&lt;p&gt;This is the most reliable approach to get documentation &lt;strong&gt;and&lt;/strong&gt; working examples. However, you need a framework that dictates how to write API code and how to write test code in order to keep documentation and examples in sync. This is another story which I&amp;rsquo;ll tell in next article :)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;And here you have full protection!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://elgris.github.io/img/apitest/4.jpg&#34; alt=&#34;almost a tank&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;apitest-https-github-com-seesawlabs-apitest-to-the-rescue:953fe4fc11a9836b4a4465fc46f3be77&#34;&gt;&lt;a href=&#34;https://github.com/seesawlabs/apitest&#34;&gt;apitest&lt;/a&gt; to the rescue!&lt;/h1&gt;

&lt;p&gt;Now let&amp;rsquo;s review an example of API test with test framework &lt;a href=&#34;https://github.com/seesawlabs/apitest&#34;&gt;apitest&lt;/a&gt;. Why it&amp;rsquo;s framework? Well, it constrains you. You have to define tests in a specific way. Also, for &lt;a href=&#34;https://github.com/seesawlabs/apitest&#34;&gt;apitest&lt;/a&gt; there is no &amp;ldquo;unit-test&amp;rdquo;. API testing is treated as testing of black box with all dependencies enabled/mocked/whatever. That is, you have some input, you have a blackbox and some expected output. &lt;a href=&#34;https://github.com/seesawlabs/apitest&#34;&gt;apitest&lt;/a&gt; just takes the input, calls a black box and compares output with expected result.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a brief overview how write tests with &lt;a href=&#34;https://github.com/seesawlabs/apitest&#34;&gt;apitest&lt;/a&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;For each API endpoint implement interface &lt;code&gt;IApiTest&lt;/code&gt;.
1.1. If you need to run some logic before a test or after it, &lt;a href=&#34;https://github.com/seesawlabs/apitest&#34;&gt;apitest&lt;/a&gt; provides interfaces &lt;code&gt;ISetuppable&lt;/code&gt; and &lt;code&gt;ITeardownable&lt;/code&gt; with methods &lt;code&gt;SetUp()&lt;/code&gt; and &lt;code&gt;TearDown()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Populate the test with &lt;code&gt;[]ApiTestCase&lt;/code&gt; - one test case for every HTTP result code that your API returns.&lt;/li&gt;
&lt;li&gt;Instantiate or implement &lt;code&gt;ITestRunner&lt;/code&gt; (&lt;a href=&#34;https://github.com/seesawlabs/apitest&#34;&gt;apitest&lt;/a&gt; provides basic one) and feed it &lt;code&gt;[]IApiTest&lt;/code&gt;. Now you have your tests running.&lt;/li&gt;
&lt;li&gt;Instantiate or implement &lt;code&gt;IDocGenerator&lt;/code&gt; (&lt;a href=&#34;https://github.com/seesawlabs/apitest&#34;&gt;apitest&lt;/a&gt; provides generator for Swagger) and feed it &lt;code&gt;[]IApiTest&lt;/code&gt;. Now you have your documentation generated.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;define-an-api:953fe4fc11a9836b4a4465fc46f3be77&#34;&gt;Define an API&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s define a small example. A simple API with 2 methods: one of them is extremely simple &amp;ldquo;Hello world&amp;rdquo; API and another one - a little bit more complex method queries Github API for details of some user. We can use any toolset we want, let it be &lt;code&gt;echo&lt;/code&gt; framework&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;errors&amp;quot;
	&amp;quot;net/http&amp;quot;

	&amp;quot;github.com/labstack/echo&amp;quot;
	mw &amp;quot;github.com/labstack/echo/middleware&amp;quot;
	&amp;quot;github.com/octokit/go-octokit/octokit&amp;quot;
)

func main() {
	e := echo.New()

	e.Use(mw.Logger())
	e.Use(mw.Recover())

	// Routes
	e.Get(&amp;quot;/hello&amp;quot;, hello)
	e.Get(&amp;quot;/user/:name&amp;quot;, getUser)

	// Start server
	e.Run(&amp;quot;:1323&amp;quot;)
}

func hello(c *echo.Context) error {
	return c.String(http.StatusOK, &amp;quot;Hello World!\n&amp;quot;)
}

func getUser(c *echo.Context) error {
	username := c.Param(&amp;quot;name&amp;quot;)
	if username == &amp;quot;&amp;quot; {
		return errors.New(&amp;quot;parameter &#39;name&#39; must be provided&amp;quot;)
	}

	user, found, err := fetchUserFromGithub(username)
	if err != nil {
		return c.String(http.StatusInternalServerError, err.Error())
	} else if !found {
		return c.String(http.StatusNotFound, &amp;quot;user %s not found&amp;quot;, username)
	}

	return c.JSON(http.StatusOK, user)
}

func fetchUserFromGithub(username string) (user *octokit.User, found bool, err error) {
	if username == &amp;quot;BadGuy&amp;quot; {
		return nil, false, errors.New(&amp;quot;BadGuy failed me :(&amp;quot;)
	}
	client := octokit.NewClient(nil)
	userURL, _ := octokit.UserURL.Expand(octokit.M{&amp;quot;user&amp;quot;: username})

	var result *octokit.Result
	user, result = client.Users(userURL).One()

	found = true
	if result.Err != nil {
		err = result.Err
		if responseErr, ok := result.Err.(*octokit.ResponseError); ok {
			found = responseErr.Type != octokit.ErrorNotFound
			if !found {
				err = nil
			}
		}

	}

	return user, found, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;write-tests-for-the-api:953fe4fc11a9836b4a4465fc46f3be77&#34;&gt;Write tests for the API&lt;/h2&gt;

&lt;p&gt;In order to write tests &lt;code&gt;apitest&lt;/code&gt;-way you need to implement &lt;code&gt;IApiTest&lt;/code&gt; interface, 1 implementation for each API endpoint. Each implementation must provide &lt;code&gt;[]ApiTestcase&lt;/code&gt;, 1 test case for each HTTP response code.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s cover our 2 API endpoints with tests:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type HelloTest struct {
}

func (t *HelloTest) Method() string      { return &amp;quot;GET&amp;quot; }
func (t *HelloTest) Description() string { return &amp;quot;Test for HelloWorld API handler&amp;quot; }
func (t *HelloTest) Path() string        { return &amp;quot;hello&amp;quot; }
func (t *HelloTest) TestCases() []testilla.ApiTestCase {
	return []testilla.ApiTestCase{
		{
			ExpectedHttpCode: 200,
			ExpectedData:     []byte(&amp;quot;Hello World!\n&amp;quot;),
		},
	}
}


type GetUserTest struct {
}

func (t *GetUserTest) Method() string      { return &amp;quot;GET&amp;quot; }
func (t *GetUserTest) Description() string { return &amp;quot;Test for GetUser API handler&amp;quot; }
func (t *GetUserTest) Path() string        { return &amp;quot;user/{username}&amp;quot; }

func (t *GetUserTest) TestCases() []testilla.ApiTestCase {
	elgrisCreatedAt := time.Date(2012, time.June, 29, 11, 57, 38, 0, time.UTC)
	elgrisUpdatedAt := time.Date(2015, time.December, 27, 19, 33, 41, 0, time.UTC)

	return []testilla.ApiTestCase{
		{
			Description: &amp;quot;Successful getting of user details&amp;quot;,
			PathParams: testilla.ParamMap{
				&amp;quot;username&amp;quot;: testilla.Param{Value: &amp;quot;elgris&amp;quot;},
			},

			ExpectedHttpCode: 200,
			ExpectedData: octokit.User{
				AvatarURL:         &amp;quot;https://avatars.githubusercontent.com/u/1905821?v=3&amp;quot;,
				Blog:              &amp;quot;http://elgris-blog.blogspot.com/&amp;quot;,
				CreatedAt:         &amp;amp;elgrisCreatedAt,
				UpdatedAt:         &amp;amp;elgrisUpdatedAt,
				EventsURL:         &amp;quot;https://api.github.com/users/elgris/events{/privacy}&amp;quot;,
				Followers:         10,
				FollowersURL:      &amp;quot;https://api.github.com/users/elgris/followers&amp;quot;,
				Following:         3,
				FollowingURL:      &amp;quot;https://api.github.com/users/elgris/following{/other_user}&amp;quot;,
				GistsURL:          &amp;quot;https://api.github.com/users/elgris/gists{/gist_id}&amp;quot;,
				Hireable:          true,
				HTMLURL:           &amp;quot;https://github.com/elgris&amp;quot;,
				ID:                1905821,
				Location:          &amp;quot;Saint Petersburg, Russia&amp;quot;,
				Login:             &amp;quot;elgris&amp;quot;,
				Name:              &amp;quot;elgris&amp;quot;,
				OrganizationsURL:  &amp;quot;https://api.github.com/users/elgris/orgs&amp;quot;,
				PublicRepos:       24,
				ReceivedEventsURL: &amp;quot;https://api.github.com/users/elgris/received_events&amp;quot;,
				ReposURL:          &amp;quot;https://api.github.com/users/elgris/repos&amp;quot;,
				StarredURL:        &amp;quot;https://api.github.com/users/elgris/starred{/owner}{/repo}&amp;quot;,
				SubscriptionsURL:  &amp;quot;https://api.github.com/users/elgris/subscriptions&amp;quot;,
				Type:              &amp;quot;User&amp;quot;,
				URL:               &amp;quot;https://api.github.com/users/elgris&amp;quot;,
			},
		},
		{
			Description: &amp;quot;404 error in case user not found&amp;quot;,
			PathParams: testilla.ParamMap{
				&amp;quot;username&amp;quot;: testilla.Param{Value: &amp;quot;someveryunknown&amp;quot;},
			},

			ExpectedHttpCode: 404,
			ExpectedData:     []byte(&amp;quot;user someveryunknown not found&amp;quot;),
		},
		{
			Description: &amp;quot;500 error in case something bad happens&amp;quot;,
			PathParams: testilla.ParamMap{
				&amp;quot;username&amp;quot;: testilla.Param{Value: &amp;quot;BadGuy&amp;quot;},
			},

			ExpectedHttpCode: 500,
			ExpectedData:     []byte(&amp;quot;BadGuy failed me :(&amp;quot;),
		},
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need a test runner in order to run tests and doc generator to generate swagger specification:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-start_test.go&#34;&gt;package main

import (
   &amp;quot;testing&amp;quot;

   &amp;quot;github.com/go-swagger/go-swagger/spec&amp;quot;
   &amp;quot;github.com/seesawlabs/testilla&amp;quot;
)

func TestApi(t *testing.T) {
   tests := []testilla.IApiTest{
      &amp;amp;HelloTest{},
      &amp;amp;GetUserTest{},
   }

   runner := testilla.NewRunner(&amp;quot;http://127.0.0.1:1323/&amp;quot;)
   runner.Run(tests, t)

   if !t.Failed() {
      seed := spec.Swagger{}
      seed.Host = &amp;quot;127.0.0.1:1323&amp;quot;
      seed.Produces = []string{&amp;quot;application/json&amp;quot;}
      seed.Consumes = []string{&amp;quot;application/json&amp;quot;}
      seed.Schemes = []string{&amp;quot;http&amp;quot;}
      seed.Info = &amp;amp;spec.Info{}
      seed.Info.Description = &amp;quot;Our very little example API with 2 endpoints&amp;quot;
      seed.Info.Title = &amp;quot;Example API&amp;quot;
      seed.Info.Version = &amp;quot;0.1&amp;quot;
      seed.BasePath = &amp;quot;/&amp;quot;

      generator := testilla.NewSwaggerYmlGenerator(seed)

      doc, err := generator.Generate(tests)
      if err != nil {
         t.Fatalf(&amp;quot;could not generate docs: %s&amp;quot;, err.Error())
      }

      t.Log(string(doc))
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;
The example is provided in [apitest repo](&lt;a href=&#34;https://github.com/seesawlabs/apitest/tree/master/example]&#34;&gt;https://github.com/seesawlabs/apitest/tree/master/example]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now if we start our API on &lt;code&gt;127.0.0.1:1323&lt;/code&gt; and run &lt;code&gt;go test&lt;/code&gt;, documentation will be generated and spit in stdout in case of success.&lt;/p&gt;

&lt;h2 id=&#34;extensibility-of-apitest:953fe4fc11a9836b4a4465fc46f3be77&#34;&gt;Extensibility of &lt;code&gt;apitest&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/seesawlabs/apitest&#34;&gt;apitest&lt;/a&gt; gives you an idea, set of interfaces and a bunch of things that can be used as examples. But nothing limits your freedom of imagination! You don&amp;rsquo;t like Swagger? Implement &lt;code&gt;IDocGenerator&lt;/code&gt; for Postman or API Blueprint or RAML, whatever! Have better idea for test runner? Just implement your very own &lt;code&gt;ITestRunner&lt;/code&gt;. Just don&amp;rsquo;t forget to send us a pull request, so everybody can enjoy your generator :). Contributions are more than welcome!&lt;/p&gt;

&lt;h2 id=&#34;conclusions:953fe4fc11a9836b4a4465fc46f3be77&#34;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;We described ways of building and maintaining documentation for API. Obviousely, doing this job manually is&amp;hellip; well&amp;hellip; manual, boring job :). Generating docs out of code or tests is a way more efficient and less error-prone. Which way to go? Use API source code only? Or use tests as a source of docs? Or combine both approaches? It&amp;rsquo;s up to you, but you should know that in &lt;code&gt;SeeSawLabs&lt;/code&gt; we believe that humans must not be slaves for machines, so we give you &lt;a href=&#34;https://github.com/seesawlabs/apitest&#34;&gt;apitest&lt;/a&gt; and encourage you to automate as much as you can :)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>